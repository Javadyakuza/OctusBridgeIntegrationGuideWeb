import { Address, Contract, GetExpectedAddressParams, ProviderRpcClient } from "everscale-inpage-provider";
import { ConstructorParams, ContractWithName, DeployTransaction, Optional } from "locklift/types";
import { Giver } from "locklift/internal/factory/giver";
import { AccountFactory2 } from "locklift/internal/factory/account2";
import { SimpleAccountsStorage } from "everscale-standalone-client/nodejs";
export * from "locklift/internal/factory/giver";
export * from "locklift/internal/factory/deployer";
export type ContractData<Abi> = {
    code: string;
    tvc: string;
    abi: Abi;
    codeHash: string;
};
export type FactoryType = Record<string, any>;
export type DeployContractParams<T extends FactoryType, ContractName extends keyof T> = {
    contract: ContractName;
    constructorParams: ConstructorParams<T[ContractName]>;
    value: string;
} & Optional<DeployParams<T[ContractName]>, "tvc">;
export type DeployParams<Abi> = GetExpectedAddressParams<Abi> & {
    publicKey: string;
};
export declare class Factory<T extends FactoryType> {
    private readonly ever;
    private readonly giver;
    private readonly accountsStorage;
    private readonly factoryCache;
    accounts: AccountFactory2<T>;
    private constructor();
    static setup<T extends FactoryType>(ever: ProviderRpcClient, giver: () => Giver, accountsStorage: SimpleAccountsStorage): Promise<Factory<T>>;
    private get deployer();
    deployContract: <ContractName extends keyof T>(args: {
        contract: ContractName;
        constructorParams: ConstructorParams<T[ContractName]>;
        value: string;
    } & Omit<DeployParams<T[ContractName]>, "tvc"> & {
        tvc?: DeployParams<T[ContractName]>["tvc"] | undefined;
    } & {
        giver?: Giver | undefined;
    }) => Promise<{
        contract: Contract<T[ContractName]>;
    } & {
        tx: import("locklift/types").TransactionWithOutput;
    }>;
    getDeployedContract: <ContractName extends keyof T>(name: ContractName, address: Address) => Contract<T[ContractName]>;
    initializeContract: <key extends keyof T>(name: keyof T, resolvedPath: string) => Promise<ContractData<T[key]>>;
    getContractArtifacts: <key extends keyof T>(name: key) => ContractData<T[key]>;
    getAllArtifacts: () => Array<{
        contractName: keyof T;
        artifacts: ContractData<T[keyof T]>;
    }>;
    getContractByCodeHash: (codeHash: string, address: Address) => ContractWithName | undefined;
    getContractByCodeHashOrDefault: (codeHash: string, address: Address) => ContractWithName;
    private getContractsArtifacts;
}
